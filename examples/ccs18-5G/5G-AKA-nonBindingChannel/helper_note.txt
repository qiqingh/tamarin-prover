##command useful
tamarin-prover --heuristic=O --oraclename=./5G_AKA.oracle --prove=weakagreement_ue_seaf_noAsyKeyRev_noSupiRev_noSqnRev_noKeyRev_noChanRev --derivcheck-timeout=0 5G_AKA.spthy > ./origin-results/weakagreement_ue_seaf_noAsyKeyRev_noSupiRev_noSqnRev_noKeyRev_noChanRev.txt

executability_honest
executability_keyConf_honest
executability_desync
executability_resync


#########################################################
Since encrypt RAND from HN to SN and on UE is not easy to model, how about we combine the SN and the HN.

If we resume the assumption of secure channel, than the SN and HN can be one entity.




#########################################################
aliveness, which only ensures that B has been running the protocol previously, but not necessarily with A;

weak agreement, which ensures that B has previously been running the protocol with A, but not necessarily with the same data

non-injective agreement, which ensures
that B has been running the protocol with A and both agree on the
data

injective agreement, which additionally ensures that for each run of the protocol of an agent there is a unique matching run of the other agent, and prevents replay attacks.


#########################################################
weakagreement_ue_seaf_noAsyKeyRev_noSupiRev_noSqnRev_noKeyRe

rule ue_send_attachReq
	Running(idSN, ~supi, <'UE','SEAF',<'PK_SN', pk(~sk_SN)>>)
rule ue_receive_authReq_freshness_success_send_authResp
	Commit(~supi, idSN, <'UE','SEAF',<'PK_SN', pk(~sk_SN)>>)

	Commit(~supi, idSN, <'UE','SEAF',<'K_seaf', K_seaf>>),
	Commit(~supi, idSN, <'UE','SEAF',<'RAND', RAND>>),



#########################################################
concern the authentication of an agent in role 'B' to an agent in role 'A'. 

Commit(a,b,<'A','B',t>) 
Running(b,a,<'A','B',t>)

Commit(~idSN, idHN,<'SEAF','HSS',<'PK_SN', pk(~sk_SN)>>)


Running(~idHN, idSN, <'SEAF','HSS',<'PK_SN', pk(~sk_SN)>>)

First Running, than Commit




#########################################################
ssh qiqing@aisec.cse.buffalo.edu


scp ./5G_AKA_test.spthy qiqing@aisec.cse.buffalo.edu:/home/csgrad/qiqing/tamarin-prover/examples/ccs18-5G/5G-AKA-nonBindingChannel/
#########################################################


##thoughts 

need to adapt the followings:


####archive
SN:
	generate key pair <pk_SN, sk_SN>
	acquire the signature from the HN sig_SN: aenc(pk_SN, sk_HN)

	here need to decide:
	1. just let the SN to send the pk_SN to HN
	2. add two status rules
		SN send the pk_SN to HN
		HN reply with the aenc(pk_SN, sk_HN)

UE:
	also store the pk_HN

SN -> HN 
	send the signature 
HN -> SN
	send the aenc(pk_SN, sk_HN)
SN -> UE
	forward aenc(pk_SN, sk_HN)
	send the aenc(RAND, sk_SN)
UE:
	use the stored pk_HN to decrypt the aenc(pk_SN, sk_HN) to get the verified pk_SN
	use the pk_SN to decrypt the aenc(RAND, sk_SN) to get the RAND

####
SN:
	generate key pair <pk_SN, sk_SN>
	acquire the signature from the HN sig_SN

UE:
	also store the pk_HN

SN -> HN 
	send the signature 
HN -> SN
	verify signature
SN -> UE
	send the signature
UE:
	verify signature
	


###################################################
add_subscription
HSS

HSS -[Subscribe, Sqn_Create]-> !Ltk_Sym, Sqn_UE, Sqn_HSS 

###################################################
ue_send_attachReq
UE->SN
	msg = suci
		suci = < aenc{<~supi, ~R>}pk_HN, ~idHN>
Ltk_Sym -[Start_UE_Session]-> St_1_UE

###################################################
seaf_receive_attachReq_send_air
SN->HN
	msg = <suci, SNID>

SEAF -[Start_SEAF_Session]-> St_1_SEAF, SndS
	SN also send signature -> just send pk_SN 
		pk_SN

###################################################
hss_receive_air_send_aia
HN->SN
	HN encrypt pk_SN
	aenc(pk_SN, sk_HN)

HSS, RcvS, !Ltk_Sym, Sqn_HSS -[Sqn_HSS_Invariance, Src, Start_HSS_Session, HSS_Send_Aia]-> St_1_HSS, Sqn_HSS, SndS
	msgIn = <suci, SNID>
	msgOut = 5G_AV
		5G_AV = < ~RAND, HXRES_star, K_seaf, AUTN >

###################################################
seaf_receive_aia_send_authReq 
SN->UE
	SN send additional:
	aenc(pk_SN, sk_HN)
	aenc(RAND, sk_SN)

St_1_SEAF, RcvS -[Out_Src]-> St_2_SEAF		
	msgIn = 5G_AV
		5G_AV = < RAND, HXRES_star, K_seaf, AUTN >
	msgOut = < RAND, AUTN, SNID >


###################################################
ue_receive_authReq_freshness_success_send_authResp 
UE->SN
	UE get pk_SN_derive
		pk_SN_derive = adec(aenc(pk_SN, sk_HN), pk_HN)
	UE get RAND_derive
		RAND_derive = adec(aenc(RAND, sk_SN), pk_SN_derive)

St_1_UE, Sqn_UE -[Sqn_UE_Invariance, Sqn_UE_Change, Sqn_UE_Use]-> St_2_UE, Sqn_UE
	msgIn = < RAND, AUTN, SNID >
	msgOut = RES_star
    	RES_star = KDF(<CK, IK>, <SNID, RES, RAND>)

###################################################
ue_receive_authReq_fail_freshness_send_sync_failure
UE->SN
St_1_UE, Sqn_UE -[Greater_Or_Equal_Than, Sqn_UE_Invariance, Sqn_UE_Nochange]-> Sqn_UE

###################################################
seaf_receive_authResp_send_ac 
SN->HN
St_2_SEAF -[]-> St_3_SEAF, SndS

###################################################
seaf_receive_syncFailure_send_authSync 
SN->HN
St_2_SEAF -[]-> SndS

###################################################
hss_receive_ac_send_aca
HN->SN
St_1_HSS, RcvS -[HSS_End]-> SndS

###################################################
seaf_receive_aca 
SN
St_3_SEAF, RcvS -[SEAF_End]-> St_4_SEAF

###################################################
hss_receive_authSync
HN
St_1_HSS, Sqn_HSS, RcvS -[Sqn_HSS_Invariance, HSS_Resync_End]-> Sqn_HSS

###################################################
ue_key_confirmation
UE
St_2_UE, In() -[]-> out()

###################################################
seaf_key_confirmation_check
SN
St_4_SEAF, In() -[SEAF_EndConf]-> []